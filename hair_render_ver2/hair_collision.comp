#version 430

layout (local_size_x = 1, local_size_y = 1) in;

//座標データ
layout(rgba32f, binding = 0) restrict uniform imageBuffer position;

//速度データ
layout(rgba32f, binding = 1) restrict uniform imageBuffer velocity;

//力データ
layout(rgba32f, binding = 2) restrict uniform imageBuffer force;

//uniform変数
uniform float radius;		//頭の半径
uniform float hlength;		//髪の長さ
uniform float knots;		//節点の数
uniform ivec2 resolution;	//テクスチャの解像度
uniform float cnum;
uniform float clen;
uniform float adhesion;
uniform sampler3D space;

float w_max = 1.0f;

//分子間力を考慮した水の伝搬モデル
vec3 setSurfacetenshon(vec3 pos0)
{
	float cl = 3 * clen/cnum;
	vec3 s000 = vec3(pos0) / clen;
	
	vec3 s100 = s000 + vec3(cl,0,0);
	vec3 s200 = s000 + vec3(-cl,0,0);
	vec3 s010 = s000 + vec3(0,cl,0);
	vec3 s020 = s000 + vec3(0,-cl,0);
	vec3 s001 = s000 + vec3(0,0,cl);
	vec3 s002 = s000 + vec3(0,0,-cl);
	
	float sd000 = texture(space,s000 * 0.5f + 0.5f).g;
	float sd100 = texture(space,s100 * 0.5f + 0.5f).g;
	float sd200 = texture(space,s200 * 0.5f + 0.5f).g;
	float sd010 = texture(space,s010 * 0.5f + 0.5f).g;
	float sd020 = texture(space,s020 * 0.5f + 0.5f).g;
	float sd001 = texture(space,s001 * 0.5f + 0.5f).g;
	float sd002 = texture(space,s002 * 0.5f + 0.5f).g;

	float thr = 1.0f;
	sd000 = step(thr,sd000)*sd000;
	sd100 = step(thr,sd100)*sd100;
	sd200 = step(thr,sd200)*sd200;
	sd010 = step(thr,sd010)*sd010;
	sd020 = step(thr,sd020)*sd020;
	sd001 = step(thr,sd001)*sd001;
	sd002 = step(thr,sd002)*sd002;

	//水同士の分子間力
	float dwx = (sd100 - sd200) / cl;
	float dwy = (sd010 - sd020) / cl;
	float dwz = (sd001 - sd002) / cl;
	vec3 stfw = vec3(dwx,dwy,dwz);

	vec3 f = vec3(0.0f);
	float lw = length(stfw);
	f += (stfw / (lw + 0.0001f)) * adhesion; 
	//f += step(10.0f,lw) * (stfw / (lw + 0.0001f)) * ( min(lw,1.1)) * adhesion;
	return f;
}


//水の伝搬
float setWaterPropagation(vec4 pos0,vec3 pos1,vec3 pos2,float water)
{
	float dy01 = clamp(pos1.y - pos0.y,-0.5f,0.5f);
	float dy02 = clamp(pos2.y - pos0.y,-0.5f,0.5f);
	float w = water;
	
	vec4 cd1 = texture(space,(pos1.xyz) / clen * 0.5f + 0.5f);
	vec4 cd2 = texture(space,(pos2.xyz) / clen * 0.5f + 0.5f);
	
	w += 2.0f * adhesion * (cd1.y / (cd1.z + 0.0001f)) * step(w,w_max) * step(0.0,dy01) * step(0.5,pos0.w);
	//w += 2.0f * adhesion * (cd2.y / (cd2.z + 0.0001f)) * step(w,w_max) * step(0.0,dy02) * step(pos0.w,knots);
	return w;
}


//衝突計算
vec3 setForce(vec3 pos0,vec3 sID03)
{
	float cl = clen/cnum;
	vec3 f = vec3(0.0);
	vec3 cp = ((sID03 - (0.5 * cnum)) / cnum) * clen * 0.5f;
	vec4 space_data0 = texture(space,pos0 / clen * 0.5f + 0.5f);
	vec3 d = vec3(pos0.x-cp.x,pos0.y-cp.y ,pos0.z-cp.z);
	float par = space_data0.x * 0.008f;
	f += d/length(d) * par;
	return f;
}



void main() {
	
	//質点番号を算出
	ivec2 pos0_ID2 = ivec2(gl_GlobalInvocationID.xy);
	int pos0_ID = pos0_ID2.x + pos0_ID2.y * resolution.x;	//処理中の質点
	
	//positionテクスチャから座標を読み取る(wはknotsID)
	vec4 pos0 = imageLoad(position,pos0_ID);
	vec4 pos1 = imageLoad(position,pos0_ID - 1);
	vec4 pos2 = imageLoad(position,pos0_ID + 1);
	vec4 vel0 = imageLoad(velocity,pos0_ID);
	
	vec4 force0 = imageLoad(force,pos0_ID);
	
	vec3 f = force0.xyz;
	//f += setForce(pos0.xyz);
	f += setSurfacetenshon(pos0.xyz);
	f *= step(1.5, pos0.w);
	
	vel0.w = setWaterPropagation(pos0,pos1.xyz,pos2.xyz,vel0.w);
	
	imageStore( force, pos0_ID, vec4(f,pos0.w));
	imageStore( velocity, pos0_ID, vel0);
}
#version 430

layout (local_size_x = 1, local_size_y = 1,local_size_z = 1) in;

//速度データ
layout(rgba32f, binding = 0) restrict uniform image3D now_vel;

//入出力データ
layout(rgba32f, binding = 1) restrict uniform image3D now_data;
layout(rgba32f, binding = 2) restrict uniform image3D pre_data;

//uniform変数
uniform float diff;		//拡散係数
uniform float visc;		//粘性係数
uniform int resolution;	//解像度
uniform float dt;		//Δt

void main() {
	
	//質点の番号に対応するテクスチャ座標を算出
	ivec3 grid_ID = ivec3(gl_GlobalInvocationID.xyz);
	if(grid_ID.x != 0 && grid_ID.y != 0 && grid_ID.z != 0 && grid_ID.x != resolution && grid_ID.y != resolution && grid_ID.z != resolution)
	{
		//セルの数(計算するセル)
		float cell = float(resolution - 2);

		float dtl = dt * cell;

		vec4 velocity = imageLoad(now_vel,grid_ID);

		//ヘミラグランジェによる移動先
		vec3 rag = vec3(grid_ID) - dtl * velocity.xyz;

		
		//セル内に収まるように指定：step(a,x)：x >= a なら 1.0
		rag.x = step(rag.x,0.5f) * 0.5f + step(0.5f,rag.x) * rag.x;
		rag.x = step(0.5f + cell,rag.x) * (cell + 0.5f) + step(rag.x,0.5f + cell) * rag.x;

		rag.y = step(rag.y,0.5f) * 0.5f + step(0.5f,rag.y) * rag.y;
		rag.y = step(0.5f + cell,rag.y) * (cell + 0.5f) + step(rag.y,0.5f + cell) * rag.y; 
		
		rag.z = step(rag.z,0.5f) * 0.5f + step(0.5f,rag.z) * rag.z;
		rag.z = step(0.5f + cell,rag.z) * (cell + 0.5f) + step(rag.z,0.5f + cell) * rag.z; 
		
		//ヘミラグランジェ法を用いた移流計算
		ivec3 ijk0 = ivec3(rag);
		ivec3 ijk1 = ijk0 + ivec3(1,1,1);

		vec3 stu1 = rag - vec3(ijk0);
		vec3 stu0 = vec3(1,1,1) - stu1;
	
		vec3 v000 = imageLoad(pre_data,ijk0).xyz;
		vec3 v010 = imageLoad(pre_data,ivec3(ijk0.x,ijk1.y,ijk0.z)).xyz;
		vec3 v001 = imageLoad(pre_data,ivec3(ijk0.x,ijk0.y,ijk1.z)).xyz;
		vec3 v011 = imageLoad(pre_data,ivec3(ijk0.x,ijk1.y,ijk1.z)).xyz;
	
		vec3 v100 = imageLoad(pre_data,ivec3(ijk1.x,ijk0.y,ijk0.z)).xyz;
		vec3 v110 = imageLoad(pre_data,ivec3(ijk1.x,ijk1.y,ijk0.z)).xyz;
		vec3 v101 = imageLoad(pre_data,ivec3(ijk1.x,ijk0.y,ijk1.z)).xyz;
		vec3 v111 = imageLoad(pre_data,ijk1).xyz;

		vec3 A0 = stu0.y * stu0.z * v000 +  stu1.y * stu0.z * v010 + stu0.y * stu1.z * v001 + stu1.y * stu1.z * v011;
		vec3 A1 = stu0.y * stu0.z * v100 +  stu1.y * stu0.z * v110 + stu0.y * stu1.z * v101 + stu1.y * stu1.z * v111;
	
		//最終計算
		vec3 out_data = stu0.x * A0 + stu1.x * A1;

		//テクスチャに格納
		imageStore(now_data, grid_ID, vec4(out_data,0.0));
	}
}